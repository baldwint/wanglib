from pylab import gca
import matplotlib as mpl
from numpy import asarray

def density_plot(two_dimensional, horiz, vert,
                 ax=None, **kwargs):
    """
    Display a 2D density plot - like imshow, but with
    axes labels corresponding to the two axes provided.

    This will only be accurate for regularly-spaced
    x and y axes (e.g., as generated by arange or linspace).

    :param two_dimensional: data to plot. shape: (M, N)
    :param horiz: x-axis. should have length N.
    :param vert: y-axis. should have length M.
    :param ax: axis upon which to plot.

    Keyword arguments are passed to imshow.

    """
    if ax is None:
        ax = gca()
    two_dimensional = asarray(two_dimensional)
    horiz, vert = asarray(horiz), asarray(vert)
    assert two_dimensional.shape == vert.shape + horiz.shape
    horiz_spacing = (horiz[-1] - horiz[0]) / (len(horiz) - 1.)
    vert_spacing = (vert[-1] - vert[0]) / (len(vert) - 1.)
    # add spacing to the upper bounds. This aligns tick
    # marks with the lower left of pixels
    ext = [horiz[0], horiz[-1] + horiz_spacing,
           vert[0], vert[-1] + vert_spacing]
    # ok, but if the origin is in the upper left (why is this the default)
    # then things will be wrong. in this case, reverse the y-axis ticks
    origin = kwargs.get('origin', mpl.rcParams['image.origin'])
    assert origin in ('upper', 'lower')
    if origin == 'upper':
        ext[2:] = ext[2:][::-1]
    # this provides axes labels. Unfortunately it also changes
    # the aspect ratio, so we need to stretch it back.
    aspect = kwargs.pop('aspect', None)
    if aspect is None:
        aspect = abs((ext[1] - ext[0]) / (ext[3] - ext[2]))
        aspect /=  float(len(horiz))/ len(vert)
        # the first step alone gets us back to a square image aspect.
        # the second will restore the native aspect ratio of the array.
    return ax.imshow(two_dimensional, extent=ext, aspect=aspect, **kwargs)
